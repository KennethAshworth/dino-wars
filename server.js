var express = require('express');
var app = express();
var server = require('http').Server(app);
var io = require('socket.io').listen(server);

app.use('/css',express.static(__dirname + '/css'));
app.use('/js',express.static(__dirname + '/js'));
app.use('/assets',express.static(__dirname + '/assets'));

app.get('/',function(req,res){
    res.sendFile(__dirname+'/index.html');
});

server.lastPlayerID = 0;

server.listen(process.env.PORT || 8081,function(){
    console.log('Listening on '+server.address().port);
});

let bases = {};
let interval;
let base;
let spawnRate = 1000;
const mapTileSize = 36;
const unitTileSize = 24;
const movementTileSize = 4;

// Utility Functions
function convertToPixels(tileSize, pos) {
	return {
		x: pos.x * tileSize,
		y: pos.y * tileSize,
	};
}

function addOriginToTilePosition(pos, origin) {
	return {
		x: pos.x + origin.x,
		y: pos.y + origin.y,
	};
}

function loopKeys(obj, cb) {
	Object.keys(obj).forEach(cb);
}

function keyLength(object) {
    return Object.keys(object).length;
}

// Need to add a function that generates this list based on an algorithm which takes a 
// tile size of the base that is spawning and will spit out clockwise tiles offsets for 
// potential spawn locations
const spawnKeys = [{x:1,y:0}, {x:1,y:1}, {x:0,y:1}, 
	{x:-1,y:1}, {x:-1,y:0}, {x:-1,y:-1}, 
	{x:0,y:-1}, {x:1,y:-1}, {x:2,y:-1}, {x:2,y:0}, 
	{x:2,y:1}, {x:2,y:2}, {x:1,y:2}, {x:0,y:2}, {x:-1,y:2}, {x:-2,y:2}, {x:-2,y:1},
	{x:-2,y:0}, {x:-2,y:-1}, {x:-2,y:-2}, {x:-1,y:-2}, {x:0,y:-2}, {x:1,y:-2}, {x:2,y:-2},
	{x:3,y:-2}, {x:3,y:-1}, {x:3,y:0}];

function Base(baseConfig) {
	this.id = baseConfig.id;
	this.race = baseConfig.race;
	this.position = baseConfig.position;
	this.spawnMap = new Map();
	this.nextUnitId = 0;
	this.units = {};
	this.type = 'Base';
}

Base.prototype.addUnit = function(){
	const origin = {x:0.5,y:0.5};
	let spawnLoc = this.getNextSpawnLoc();
	if (spawnLoc != false)
	{
		const unitId = this.nextUnitId++;
		spawnLoc = addOriginToTilePosition(spawnLoc, origin);
		spawnLoc = convertToPixels(unitTileSize, spawnLoc);
	
		const unit = {
			id:unitId,
			baseId:this.id,
			type:this.race,
			//spawnPosition: {x:spawnLoc.x, y:spawnLoc.y},
			position: {x:spawnLoc.x, y:spawnLoc.y},
		};
		// need to verify the x and y values between what i send down and what is generated by the sprite factory
		this.units[unitId] = unit 
		//console.log(this.units);
		return unit;	
	}
	else
	{
		return false;
	}
	//console.log('not returning unit');
}

Base.prototype.getNextSpawnLoc = function(){
	let spawnOffset;
	let spawnLocFound = true;
	let units = base.units;
	const unitCount = keyLength(units);

	let spawnTile = {};
	for(let i = 0; i < spawnKeys.length; i++) {
		spawnOffset = spawnKeys[i];
		spawnTile = {
			x: this.position.x + spawnOffset.x, 
			y: this.position.y + spawnOffset.y
		};

		if (unitCount === 0)
		{
			// return the default spawnLocation when no units have spawned yet	
			break;		
		}
		else
		{
			for(let j = 0; j < unitCount; j++) 
			{
				// record that this unit is in the tile domain 
				if (isUnitInTile(units[j], spawnTile, unitTileSize))
				{
					spawnLocFound = false;
					break;
				}
			}
		}
		// no possible spawnLocations available.
		if (i === spawnKeys.length - 1)
			return false;

		if(spawnLocFound === true)
			break;

		spawnLocFound = true;
	}

	if (spawnLocFound === true)
		return spawnTile;
}

// this could also be a unit method called unit.isInTile() returns bool
// probally makes more sense for each unit to tell which tiles it is in
// vs trying to calc whether or not a unit is in a specific tile
// since knowing one sprite location would give us info on specifically which tiles it
// would have to overlap with...
let trace = 1;
// for now just check if the central point is in the given tile
// todo-ken: would be interesting if the "body" of a unit was less that the sprite such that only their lower
// third counted as being in a tile and other unit collisions, this would allows a stacking type of effect
// of units while maintaining individual visual units. Would need to overlap the sprite at the higher Y values 
// over the z values of the sprite with lower X values...
function isUnitInTile(unit, tile, tileSize) {
  const largeX = (tile.x + 1) * tileSize;
  const smallX = tile.x * tileSize;
  const posX = unit.position.x;
  const largeY = (tile.y + 1) * tileSize;
  const smallY = tile.y * tileSize;
  const posY = unit.position.y;
  
  if (posX > smallX && posX < largeX && 
  	  	posY > smallY && posY < largeY) {
      return true;
  }
  else {
  	return false;
  }
}

// outdated for now
function getSpriteCoord(x, y, offset) {
    const tileCoord = getMapCoord(x, y) 
    const spriteX = tileCoord.x + offset;
    const spriteY = tileCoord.y + offset;   
    return { x: spriteX, y: spriteY };
};
// outdated for now
function getMapCoord(x, y) {
    const mapX = Math.floor(x*24);
    const mapY = Math.floor(y*24);
    return { x: mapX, y:mapY };
}

// determined by number of players in room?
const basesConfig = [
	{
		id:1,
		race:'red',
		position:{x:2,y:2}, 
	}
];

io.on('connection', function(socket) {
	console.log('User connected');
	socket.on('createBases', function() {
		// for now lets just have 1 base generate 1 red dino to the right
		// bases = generateBases(basesConfig);
		// base = basesConfig[0]
		// base.units = [];
		// base.type = 'Base';
		base = new Base(basesConfig[0]);
		io.emit('createBases', base);
		interval = setInterval(function(){
			addUnits();
		}, spawnRate);

		//socket.player = {
		//	id: server.lastPlayerID++,
		//	x: randomInt(100, 400),
		//	y: randomInt(100,400)
		//};
		//socket.emit('allplayers', getAllPlayers());
		//socket.broadcast.emit('newplayer', socket.player);

		//socket.on('click', function(data) {
		//	console.log('click to ' + data.x + ', ' + data.y);
		//	socket.player.x = data.x;
		//	socket.player.y = data.y;
		//	io.emit('move', socket.player);
		//});

		socket.on('updateUnits', function(units) {
			loopKeys(units, function(id) {
				const unit = units[id];
				base.units[unit.id] = unit;
			});
		});
		
	});

	socket.on('disconnect', function(){
			console.log('user disconnected');
			clearInterval(interval);
			// todo-ken will be needed for actions in lobby and
			// player dc, io.emit('remove', socket.player.id);
		});
});

function addUnits() {
	//bases.forEach(function(base){
		const unit = base.addUnit();
		if (unit !== false) {
			io.emit('addUnit', unit);	
		}
	//});
}

function generateBases(basesConfig) {
	basesConfig.forEach(function(config){
		console.log(new Base(config));
		bases.push(new Base(config));
	});
} 

// function getAllPlayers() {
// 	var players = [];
// 	Object.keys(io.sockets.connected).forEach(function(socketID) {
// 		var player = io.sockets.connected[socketID].player;
// 		if(player)
// 			players.push(player);
// 	});
// 	return players;
// }

function randomInt(low, high) {
	return Math.floor(Math.random() * (high - low) + low);
}